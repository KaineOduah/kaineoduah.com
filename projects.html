<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Projects — Kaine Oduah</title>
  <meta name="description" content="Kaine Oduah — portfolio and projects." />
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;800;900&display=swap" rel="stylesheet" />
  <link rel="stylesheet" href="assets/css/style.css" />
  <script>if(location.protocol!=='https:')location.replace('https://'+location.host+location.pathname+location.search+location.hash);</script>
  <link rel="canonical" href="https://kaineoduah.com/projects.html" />
</head>
<body data-page="projects">
<header class="site-nav">
  <div class="container">
    <a class="brand" href="index.html">Main Page</a>
    <nav>
      <a href="experience.html" class="">Experience</a>
      <a href="projects.html" class="active">Projects</a>
      <a href="certificates.html" class="">Certificates</a>
      <a href="contact.html" class="">Contact</a>
    </nav>
  </div>
</header>

<main class="container">
  <section class="section reveal">
    <h2 class="section-title">PROJECTS</h2>

    <article class="project" id="zfish">
      <div class="project-head">
        <h3>Zebrafish Brain Segmentation (U‑Net)</h3>
        <span class="years">2025</span>
      </div>
      <p><strong>Overview:</strong> This project delivers pixel‑accurate segmentation masks for zebrafish brain images so research teams can quantify structure at scale. Instead of hand‑drawing masks one image at a time, collaborators receive consistent, machine‑readable outputs that plug into downstream analysis—surface area, boundary length, symmetry, and region comparisons across cohorts.</p>
      <p><strong>My Role:</strong> I designed the end‑to‑end pipeline: dataset specification, augmentation policy, model choice, training/evaluation routines, and a results notebook that makes the model’s behavior legible to non‑ML collaborators. The focus wasn’t novelty; it was reliability and explainability for a small but important dataset.</p>
      <p><strong>Approach:</strong> Inputs are paired TIFF images and PNG masks with a simple, reproducible split. Augmentations (mirrors, slight rotations, elastic deformations, controlled brightness/contrast jitter) encourage generalization without distorting anatomy. A U‑Net with a ResNet‑34 encoder (ImageNet initialization) gives strong performance with modest compute. I bias the loss toward boundary fidelity using a Dice‑style objective so thin structures aren’t washed out by background class dominance. Evaluation reports both Dice and IoU along with per‑case visuals and “failure galleries” that highlight uncertainty and edge cases.</p>
      <p><strong>Design Choices:</strong> The pipeline is intentionally transparent: no hidden heuristics, minimal post‑processing, and clear ablations to show the impact of each choice. Visual notebooks include side‑by‑side overlays, per‑class Dice/IoU, failure galleries, and uncertainty heuristics to flag images worth manual review. All of this is written to be a durable baseline the team can understand and extend.</p>
      <p><strong>Outcome:</strong> A dependable model that accelerates annotation, plus a documented experimental scaffold for future iterations (multi‑scale features, attention gates, or domain‑specific augmentations) as more data arrives.</p>
      <ul class="stack"><li>Python</li><li>PyTorch</li><li>OpenCV</li></ul>
      <div class="links"><a class="underline" target="_blank" rel="noopener" href="https://github.com/KaineOduah/zebrafish-brain-segmentation">GitHub</a></div>
    </article>

    <article class="project" id="sunlab">
      <div class="project-head">
        <h3>Lab Access System</h3>
        <span class="years">2024</span>
      </div>
      <p><strong>Overview:</strong> A desktop system that mirrors swipe‑card entry for a university lab. It tracks precisely who entered, when, and under which permission profile, with an operator view optimized for real‑world pressure—rushes at the top of the hour, confused users, and the need to answer “who was here last night?” in seconds.</p>
      <p><strong>My Role:</strong> I owned the application from data model to UI. The work included designing a normalized SQLite schema, building a clear GUI for enrollment and audit, and writing guardrails that prevent accidental edits without nagging users.</p>
      <p><strong>Approach:</strong> The interface favors decisiveness: large, obvious actions; inline validation; and persistent status messaging so operators never wonder what just happened. The persistence layer is abstracted so future hardware integrations (e.g., physical reader) wouldn’t force a rewrite. Reports filter by name, date range, and status with exports suitable for policy review.</p>
      <p><strong>Design Choices:</strong> Accessibility and speed trumped novelty. Keyboard paths are consistent; destructive actions require explicit confirmation; and the system communicates in plain language. By separating GUI logic from storage, the app remains easy to maintain and extend.</p>
      <p><strong>Outcome:</strong> A reliable workflow that replaces scattered logs with a single source of truth, reducing incident resolution time and making compliance checks straightforward.</p>
      <ul class="stack"><li>Python</li><li>SQLite</li><li>Tkinter</li></ul>
      <div class="links"><a class="underline" target="_blank" rel="noopener" href="https://github.com/KaineOduah/SUN_Lab_Project">GitHub</a></div>
    </article>

    <article class="project" id="maint">
      <div class="project-head">
        <h3>Maintenance Request Web App</h3>
        <span class="years">2023</span>
      </div>
      <p><strong>Overview:</strong> A small full‑stack system that moves facility issues from report to resolution without the usual ambiguity. Requesters submit clear descriptions with location/category/impact; staff triage, assign, and update status; stakeholders see a transparent timeline that keeps questions to a minimum.</p>
      <p><strong>My Role:</strong> I handled the end‑to‑end application—data model, server logic, and interface. The goal was consistency and calm under load, not a pile of frameworks.</p>
      <p><strong>Approach:</strong> Server‑rendered pages keep the app fast and predictable. Forms validate the essentials and nudge users toward the details that actually help the team act. Records move through a simple lifecycle (new → triaged → assigned → in progress → done) with timestamped updates and an audit trail that supports lightweight reporting.</p>
      <p><strong>Design Choices:</strong> The UI uses progressive disclosure to avoid overwhelming new users. Copy is written to reduce support questions; list views surface the work that’s blocked or ageing out. The database schema is explicit and readable so future teammates can maintain it without guesswork.</p>
      <p><strong>Outcome:</strong> Faster resolution, fewer back‑and‑forth messages, and predictable reporting for managers who need a snapshot at the end of the week.</p>
      <ul class="stack"><li>HTML</li><li>CSS</li><li>PHP</li><li>MySQL</li></ul>
      <div class="links"><a class="underline" target="_blank" rel="noopener" href="https://github.com/KaineOduah/Maintenance-Web-App">GitHub</a></div>
    </article>
  </section>
</main>

<footer class="footer">
  <div class="container">
    <div>© <span id="year"></span> Kaine Oduah</div>
  </div>
</footer>
<script src="assets/js/app.js"></script>
</body>
</html>
